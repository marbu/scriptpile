#!/usr/bin/env python3
# -*- coding: utf8 -*-

# Copyright 2025 Martin Bukatoviƒç <martinb@marbu.eu>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import argparse
import hashlib
import os
import os.path
import sys
import urllib.parse


LINK_DIR = "link"
WIKI_GITIT_DIR = "/home/martin/tvorba/gitit.wiki"  # TODO: move to config file
WIKI_LINK_PATH = os.path.join(WIKI_GITIT_DIR, "static", LINK_DIR)
WIKI_LINK_ROOT = os.path.join("/", LINK_DIR)


SYNTAX_TYPES = {
    "md": "[`{0}`]({1})",
    "org": "[[.{1}][~{0}~]]",
    "rst": "`{0} <{1}>`_"}


def symlink_to_wiki(file_path, preserve_basename=False):
    """
    Symlinkg given file and generate wiki path for linking.
    """
    if file_path.startswith("file:///"):
        # translate local file urls (when copy pasting from a browser)
        result = urllib.parse.urlparse(file_path)
        file_path = result.path
    if not preserve_basename:
        # compute sha256 digest
        with open(file_path, "rb") as fo:
            digest = hashlib.sha256(fo.read()).hexdigest()
        _, ext = os.path.splitext(file_path)
        link_name = digest + ext
        wiki_path = os.path.join(WIKI_LINK_ROOT, link_name)
    else:
        link_name = os.path.basename(file_path)
        wiki_path = os.path.join(WIKI_LINK_ROOT, link_name)
    # and symlink the file to wiki static dir
    real_path = os.path.realpath(file_path)
    try:
        os.symlink(real_path, os.path.join(WIKI_LINK_PATH, link_name))
    except FileExistsError:
        if preserve_basename:
            print((
                f"warning: file '{link_name}' has been already linked, "
                "check for collisions!"),
                file=sys.stderr)
    return wiki_path


def get_link(file_name, wiki_path, syntax):
    """
    Generate link for given path in given syntax.
    """
    return SYNTAX_TYPES[syntax].format(file_name, wiki_path)


def get_file_path(url):
    """
    Return original full file path for a given wiki url generated by
    symlink_to_wiki.
    """
    result = urllib.parse.urlparse(url)
    if result.path.startswith("/"):
        file_path = result.path[1:]
    else:
        file_path = result.path
    link_path = os.path.join(WIKI_GITIT_DIR, "static", file_path)
    real_path = os.readlink(link_path)
    return real_path


def main():
    ap = argparse.ArgumentParser(
        description="create wiki link for given local file")
    ap.add_argument("file", nargs='+', help="local file to link to")
    ap.add_argument(
        "-s",
        dest="syntax",
        choices=SYNTAX_TYPES.keys(),
        default="md",
        help="link syntax, md (markdown) is used if not specified")
    ap.add_argument(
        "-p",
        "--preserve-name",
        action="store_true",
        help=(
            "preserve filename when symlinking, "
            "use only with important and unique file names"))
    ap.add_argument(
        "--url2path",
        action="store_true",
        help="translate wiki url to a file path (reverse operation)")
    args = ap.parse_args()

    retcode = 0

    for file_path in args.file:
        try:
            if args.url2path:
                print(get_file_path(file_path))
            else:
                wiki_path = symlink_to_wiki(file_path, args.preserve_name)
                file_name = os.path.basename(file_path)
                link_code = get_link(file_name, wiki_path, args.syntax)
                print(link_code)
        except FileNotFoundError as ex:
            retcode = 1
            print(ex, file=sys.stderr)
            continue

    return retcode


if __name__ == '__main__':
    sys.exit(main())
